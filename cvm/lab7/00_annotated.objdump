02. o:	file format mach-o 32-bit i386

Disassembly of section __TEXT,__text:

00000000 <_main>:
; int main(void) {
       0: 55                           	push	ebp                      ; сохранить старый кадр стека
       1: 89 e5                        	mov	ebp, esp                     ; установить новый кадр (ebp = esp)
       3: 57                           	push	edi                      ; сохранить регистр edi (callee-saved)
       4: 56                           	push	esi                      ; сохранить регистр esi (callee-saved)
       5: 83 ec 20                     	sub	esp, 0x20                    ; зарезервировать 32 байта на стеке для локальных переменных
       8: e8 00 00 00 00               	call	0xd <_main+0xd>          ; вызов следующей инструкции (PIC trick для получения адреса)
       d: 58                           	pop	eax                          ; вернуть адрес вызова в eax (PIC base)
       e: 89 45 e8                     	mov	dword ptr [ebp - 0x18], eax  ; сохранить PIC base в локальной переменной [ebp-0x18]
      11: c7 45 f4 00 00 00 00         	mov	dword ptr [ebp - 0xc], 0x0   ; инициализация временной/локальной ячейки = 0
;     long lVar = 100L;  
      18: c7 45 f0 64 00 00 00         	mov	dword ptr [ebp - 0x10], 0x64 ; lVar = 100 (локальная переменная long, 4 байта в 32-бит режиме)
;     for (i = 0; i < 9; i++) {         инициализация цикла
      1f: 8b 80 7c 06 00 00            	mov	eax, dword ptr [eax + 0x67c] ; загрузить адрес глобальной переменной i из GOT (PIC base + offset)
      25: c7 00 00 00 00 00            	mov	dword ptr [eax], 0x0         ; записать 0 в память по адресу i -> i = 0
      2b: 8b 45 e8                     	mov	eax, dword ptr [ebp - 0x18]  ; восстановить PIC base из стека
;     for (i = 0; i < 9; i++) {         проверка условия цикла
      2e: 8b 80 7c 06 00 00            	mov	eax, dword ptr [eax + 0x67c] ; загрузить адрес i
      34: 83 38 09                     	cmp	dword ptr [eax], 0x9         ; сравнить *i с 9
      37: 0f 83 ab 00 00 00            	jae	0xe8 <_main+0xe8>            ; если i >= 9, выйти из цикла (переход к адресу 0xe8)
      3d: 8b 45 e8                     	mov	eax, dword ptr [ebp - 0x18]  ; подготовка для проверки условия if
;         if ((i > 3) && (i != 6))      проверка первого условия (i > 3)
      40: 8b 80 7c 06 00 00            	mov	eax, dword ptr [eax + 0x67c] ; загрузить адрес i из GOT
      46: 83 38 03                     	cmp	dword ptr [eax], 0x3         ; сравнить *i с 3
      49: 0f 86 45 00 00 00            	jbe	0x94 <_main+0x94>            ; если i <= 3, перейти в else (адрес 0x94)
      4f: 8b 45 e8                     	mov	eax, dword ptr [ebp - 0x18]  ; снова подготовить PIC base
;         if ((i > 3) && (i != 6))      проверка второго условия (i != 6)
      52: 8b 80 7c 06 00 00            	mov	eax, dword ptr [eax + 0x67c] ; загрузить адрес i
      58: 83 38 06                     	cmp	dword ptr [eax], 0x6         ; сравнить *i с 6
      5b: 0f 84 33 00 00 00            	je	0x94 <_main+0x94>            ; если i == 6, перейти в else (short-circuit evaluation)
      61: 8b 75 e8                     	mov	esi, dword ptr [ebp - 0x18]  ; esi = PIC base (используется как контекст для доступа к глобалам)
;             cMas[i] = (8 * i) | 0x3;  then-ветка: вычисление (8*i)|3
      64: 8b 86 7c 06 00 00            	mov	eax, dword ptr [esi + 0x67c] ; eax = адрес i (через esi + offset)
      6a: 8b 10                        	mov	edx, dword ptr [eax]         ; edx = значение i
      6c: 8b 86 7c 06 00 00            	mov	eax, dword ptr [esi + 0x67c] ; повторная загрузка адреса i
      72: c1 e2 03                     	shl	edx, 0x3                     ; edx <<= 3  (умножение i на 8)
      75: 83 ca 03                     	or	edx, 0x3                     ; edx |= 3  (установить младшие биты)
      78: 8b 86 7c 06 00 00            	mov	eax, dword ptr [esi + 0x67c] ; eax = адрес i (для индекса)
      7e: 8b 08                        	mov	ecx, dword ptr [eax]         ; ecx = i (индекс для массива)
      80: 8b 86 78 06 00 00            	mov	eax, dword ptr [esi + 0x678] ; eax = базовый адрес массива cMas (загрузка из GOT через esi + 0x678)
      86: 8b b6 7c 06 00 00            	mov	esi, dword ptr [esi + 0x67c] ; esi = адрес i (временное сохранение)
      8c: 89 14 88                     	mov	dword ptr [eax + 4*ecx], edx ; запись: cMas[ecx] = edx  (многокомпонентная адресация: base + index*4)
      8f: e9 2e 00 00 00               	jmp	0xc2 <_main+0xc2>            ; перейти к инкременту (пропустить else-ветку)
      94: 8b 75 e8                     	mov	esi, dword ptr [ebp - 0x18]  ; else-ветка: esi = PIC base
;             cMas[i] = (int)25 * i / 3; else-ветка: вычисление 25*i/3
      97: 8b 86 7c 06 00 00            	mov	eax, dword ptr [esi + 0x67c] ; eax = адрес i
      9d: 6b 00 19                     	imul	eax, dword ptr [eax], 0x19 ; eax = i * 25  (трёхоперандная форма imul с immediate 0x19=25)
      a0: b9 03 00 00 00               	mov	ecx, 0x3                     ; ecx = 3 (делитель)
      a5: 31 d2                        	xor	edx, edx                     ; edx = 0 (обнуление для деления, т.к. div использует EDX:EAX)
      a7: f7 f1                        	div	ecx                          ; EAX = (EDX:EAX) / ECX  (беззнаковое деление), остаток в EDX
      a9: 89 c2                        	mov	edx, eax                     ; edx = результат деления (сохранить для записи в массив)
      ab: 8b 86 7c 06 00 00            	mov	eax, dword ptr [esi + 0x67c] ; eax = адрес i (подготовка к индексации)
      b1: 8b 08                        	mov	ecx, dword ptr [eax]         ; ecx = i (индекс)
      b3: 8b 86 78 06 00 00            	mov	eax, dword ptr [esi + 0x678] ; eax = базовый адрес cMas
      b9: 8b b6 7c 06 00 00            	mov	esi, dword ptr [esi + 0x67c] ; esi = адрес i
      bf: 89 14 88                     	mov	dword ptr [eax + 4*ecx], edx ; cMas[ecx] = result  (запись результата в массив)
;     }                                конец тела цикла
      c2: e9 00 00 00 00               	jmp	0xc7 <_main+0xc7>            ; короткий переход (выровнен компилятором)
      c7: 8b 45 e8                     	mov	eax, dword ptr [ebp - 0x18]  ; загрузить PIC base для инкремента i
;     for (i = 0; i < 9; i++) {         инкремент i++
      ca: 8b 88 7c 06 00 00            	mov	ecx, dword ptr [eax + 0x67c] ; ecx = адрес i
      d0: 8b 09                        	mov	ecx, dword ptr [ecx]         ; ecx = значение i
      d2: 8b 90 7c 06 00 00            	mov	edx, dword ptr [eax + 0x67c] ; edx = адрес i (для записи позже)
      d8: 83 c1 01                     	add	ecx, 0x1                     ; ecx = i + 1
      db: 8b 80 7c 06 00 00            	mov	eax, dword ptr [eax + 0x67c] ; eax = адрес i
      e1: 89 08                        	mov	dword ptr [eax], ecx         ; записать i+1 обратно в память (i++)
      e3: e9 43 ff ff ff               	jmp	0x2b <_main+0x2b>            ; перейти к началу цикла (назад к адресу 0x2b — проверка условия)
;     result = Fn(42, &lVar);          вызов функции Fn
      e8: 8d 45 f0                     	lea	eax, [ebp - 0x10]            ; eax = адрес локальной переменной lVar (вычислить адрес без обращения к памяти)
      eb: c7 04 24 2a 00 00 00         	mov	dword ptr [esp], 0x2a        ; положить первый аргумент (42 = 0x2a) на стек: [esp] = 42
      f2: 89 44 24 04                  	mov	dword ptr [esp + 0x4], eax   ; положить второй аргумент (адрес lVar) на стек: [esp+4] = &lVar
      f6: e8 b5 00 00 00               	call	0x1b0 <_Fn>              ; вызов функции Fn(42, &lVar)
      fb: 89 c1                        	mov	ecx, eax                     ; ecx = возвращаемое значение из Fn (результат в eax)
      fd: 8b 45 e8                     	mov	eax, dword ptr [ebp - 0x18]  ; восстановить PIC base
     100: 89 4d ec                     	mov	dword ptr [ebp - 0x14], ecx  ; сохранить result в локальной переменной [ebp-0x14]
;     for (i = 0; i < 9; i++)          второй цикл: печать результатов
     103: 8b 80 7c 06 00 00            	mov	eax, dword ptr [eax + 0x67c] ; eax = адрес i
     109: c7 00 00 00 00 00            	mov	dword ptr [eax], 0x0         ; i = 0  (инициализация второго цикла)
     10f: 8b 45 e8                     	mov	eax, dword ptr [ebp - 0x18]  ; загрузить PIC base
;     for (i = 0; i < 9; i++)          проверка условия второго цикла
     112: 8b 80 7c 06 00 00            	mov	eax, dword ptr [eax + 0x67c] ; eax = адрес i
     118: 83 38 09                     	cmp	dword ptr [eax], 0x9         ; сравнить i с 9
     11b: 0f 83 5f 00 00 00            	jae	0x180 <_main+0x180>          ; если i >= 9, выйти из цикла
     121: 8b 75 e8                     	mov	esi, dword ptr [ebp - 0x18]  ; esi = PIC base (контекст для доступа к глобалам)
;         printf("cMas[%u] = %u\n", i, cMas[i]);  подготовка аргументов для printf
     124: 8b 86 7c 06 00 00            	mov	eax, dword ptr [esi + 0x67c] ; eax = адрес i
     12a: 8b 08                        	mov	ecx, dword ptr [eax]         ; ecx = i  (второй аргумент printf)
     12c: 8b 86 7c 06 00 00            	mov	eax, dword ptr [esi + 0x67c] ; eax = адрес i (снова, для индексации)
     132: 8b 10                        	mov	edx, dword ptr [eax]         ; edx = i  (используется как индекс для массива)
     134: 8b 86 78 06 00 00            	mov	eax, dword ptr [esi + 0x678] ; eax = базовый адрес cMas
     13a: 8b be 7c 06 00 00            	mov	edi, dword ptr [esi + 0x67c] ; edi = адрес i (временное сохранение)
     140: 8b 04 90                     	mov	eax, dword ptr [eax + 4*edx] ; eax = cMas[edx]  (загрузка элемента массива через многокомпонентную адресацию)
     143: 8d 96 e8 01 00 00            	lea	edx, [esi + 0x1e8]           ; edx = адрес строки формата "cMas[%u] = %u\n" (относительно esi + offset)
     149: 8b b6 78 06 00 00            	mov	esi, dword ptr [esi + 0x678] ; esi = базовый адрес cMas (восстановление)
     14f: 89 14 24                     	mov	dword ptr [esp], edx         ; положить адрес формата на стек: [esp] = format
     152: 89 4c 24 04                  	mov	dword ptr [esp + 0x4], ecx   ; положить i на стек: [esp+4] = i
     156: 89 44 24 08                  	mov	dword ptr [esp + 0x8], eax   ; положить cMas[i] на стек: [esp+8] = cMas[i]
     15a: e8 a1 fe ff ff               	call	0x0 <_main>              ; вызов printf (через PLT/GOT, реальный адрес подставится динамическим линкером)
     15f: 8b 45 e8                     	mov	eax, dword ptr [ebp - 0x18]  ; после printf: восстановить PIC base
;     for (i = 0; i < 9; i++)          инкремент i во втором цикле
     162: 8b 88 7c 06 00 00            	mov	ecx, dword ptr [eax + 0x67c] ; ecx = адрес i
     168: 8b 09                        	mov	ecx, dword ptr [ecx]         ; ecx = значение i
     16a: 8b 90 7c 06 00 00            	mov	edx, dword ptr [eax + 0x67c] ; edx = адрес i
     170: 83 c1 01                     	add	ecx, 0x1                     ; ecx = i + 1
     173: 8b 80 7c 06 00 00            	mov	eax, dword ptr [eax + 0x67c] ; eax = адрес i
     179: 89 08                        	mov	dword ptr [eax], ecx         ; записать i+1 обратно (i++)
     17b: e9 8f ff ff ff               	jmp	0x10f <_main+0x10f>          ; перейти к проверке условия второго цикла (назад к 0x10f)
     180: 8b 55 e8                     	mov	edx, dword ptr [ebp - 0x18]  ; конец цикла печати: edx = PIC base
;     printf("Fn returned: %d, lVar = %ld\n", result, lVar);  вызов printf для вывода результата Fn
     183: 8b 4d ec                     	mov	ecx, dword ptr [ebp - 0x14]  ; ecx = result (локальная переменная, сохранённая ранее)
     186: 8b 45 f0                     	mov	eax, dword ptr [ebp - 0x10]  ; eax = lVar  (локальная переменная long)
     189: 8d 92 f7 01 00 00            	lea	edx, [edx + 0x1f7]           ; edx = адрес строки формата "Fn returned: %d, lVar = %ld\n"
     18f: 89 14 24                     	mov	dword ptr [esp], edx         ; [esp] = адрес формата
     192: 89 4c 24 04                  	mov	dword ptr [esp + 0x4], ecx   ; [esp+4] = result
     196: 89 44 24 08                  	mov	dword ptr [esp + 0x8], eax   ; [esp+8] = lVar
     19a: e8 61 fe ff ff               	call	0x0 <_main>              ; вызов printf
;     return 0;                        завершение main
     19f: 31 c0                        	xor	eax, eax                     ; eax = 0  (возвращаемое значение: return 0)
     1a1: 83 c4 20                     	add	esp, 0x20                    ; восстановить стек (освободить 32 байта локальных переменных)
     1a4: 5e                           	pop	esi                          ; восстановить сохранённый регистр esi
     1a5: 5f                           	pop	edi                          ; восстановить сохранённый регистр edi
     1a6: 5d                           	pop	ebp                          ; восстановить старый кадр стека
     1a7: c3                           	ret                              ; возврат из main
     1a8: 0f 1f 84 00 00 00 00 00      	nop	dword ptr [eax + eax]        ; выравнивание (padding для следующей функции)

000001b0 <_Fn>:
; int Fn(unsigned int uiParam, long *plPtr) {
     1b0: 55                           	push	ebp                      ; сохранить старый кадр стека (пролог функции Fn)
     1b1: 89 e5                        	mov	ebp, esp                     ; установить новый кадр: ebp = esp
     1b3: 83 ec 08                     	sub	esp, 0x8                     ; зарезервировать 8 байт на стеке для локальных переменных
     1b6: 8b 45 0c                     	mov	eax, dword ptr [ebp + 0xc]   ; eax = второй параметр (plPtr, указатель на long) — загрузка из стека [ebp+0xc]
     1b9: 8b 45 08                     	mov	eax, dword ptr [ebp + 0x8]   ; eax = первый параметр (uiParam, unsigned int) — загрузка из стека [ebp+0x8]
;     lLocA = (50L - (long)uiParam) * (*plPtr);  вычисление lLocA
     1bc: b8 32 00 00 00               	mov	eax, 0x32                    ; eax = 50  (константа 0x32 = 50)
     1c1: 2b 45 08                     	sub	eax, dword ptr [ebp + 0x8]   ; eax = 50 - uiParam  (вычитание параметра из 50)
     1c4: 8b 4d 0c                     	mov	ecx, dword ptr [ebp + 0xc]   ; ecx = plPtr  (загрузить указатель из стека)
     1c7: 0f af 01                     	imul	eax, dword ptr [ecx]     ; eax = eax * (*plPtr)  (знаковое умножение: косвенная адресация [ecx])
     1ca: 89 45 fc                     	mov	dword ptr [ebp - 0x4], eax   ; сохранить результат в локальной lLocA: [ebp-0x4] = eax
;     *plPtr = lLocA / 3;              запись через указатель
     1cd: 8b 45 fc                     	mov	eax, dword ptr [ebp - 0x4]   ; eax = lLocA  (загрузить локальную переменную)
     1d0: b9 03 00 00 00               	mov	ecx, 0x3                     ; ecx = 3  (делитель)
     1d5: 99                           	cdq                              ; sign-extend EAX → EDX:EAX  (для знакового деления idiv нужен 64-битный делимое)
     1d6: f7 f9                        	idiv	ecx                      ; EAX = (EDX:EAX) / ECX (знаковое деление), остаток в EDX
     1d8: 89 c1                        	mov	ecx, eax                     ; ecx = результат деления (частное)
     1da: 8b 45 0c                     	mov	eax, dword ptr [ebp + 0xc]   ; eax = plPtr  (загрузить указатель из параметра)
     1dd: 89 08                        	mov	dword ptr [eax], ecx         ; *plPtr = ecx  (запись по адресу: косвенная адресация через указатель)
;     iResult = (int)(lLocA % 100);    вычисление остатка от деления на 100
     1df: 8b 45 fc                     	mov	eax, dword ptr [ebp - 0x4]   ; eax = lLocA
     1e2: b9 64 00 00 00               	mov	ecx, 0x64                    ; ecx = 100  (делитель для операции остатка)
     1e7: 99                           	cdq                              ; sign-extend EAX → EDX:EAX
     1e8: f7 f9                        	idiv	ecx                      ; EAX = частное, EDX = остаток (lLocA % 100)
     1ea: 89 55 f8                     	mov	dword ptr [ebp - 0x8], edx   ; сохранить остаток в локальной iResult: [ebp-0x8] = edx
;     return iResult;                  возврат из функции
     1ed: 8b 45 f8                     	mov	eax, dword ptr [ebp - 0x8]   ; eax = iResult  (загрузить возвращаемое значение)
     1f0: 83 c4 08                     	add	esp, 0x8                     ; освободить стек (восстановить esp: отменить sub esp, 0x8)
     1f3: 5d                           	pop	ebp                          ; восстановить старый кадр стека (эпилог функции)
     1f4: c3                           	ret                              ; возврат из функции Fn (возвращаемое значение в eax)