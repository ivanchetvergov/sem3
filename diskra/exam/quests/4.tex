\section{Счетные и несчетные множества. Теоремы о счетных множествах. Представление множеств в программах.}


\subsection*{Счетные и Несчетные множества.}
\paragraph{Счетное множество}
Множество $A$ называется \textbf{счетным}, если оно равномощно множеству натуральных чисел $\mathbb{N}$ (т.е., $|A| = |\mathbb{N}| = \aleph_0$). Элементы счетного множества могут быть перечислены в последовательность $a_1, a_2, a_3, \ldots$.

\paragraph{Несчетное множество}
Множество $B$ называется \textbf{несчетным}, если оно не является ни конечным, ни счетным (т.е., $|B| > |\mathbb{N}|$). \textbf{Пример:} Множество вещественных чисел $\mathbb{R}$.

\paragraph{Теорема Кантора}
Мощность булеана любого множества $A$ всегда строго больше мощности самого множества:
$$|\mathbf{2^A}| > |A|.$$
Это доказывает, что несчетные множества существуют.

\paragraph{Теорема Кантора-Бернштейна}
Если существует инъекция (вложение) множества $A$ в $B$ и инъекция $B$ в $A$, то множества $A$ и $B$ равномощны:
$$(A \hookrightarrow B \land B \hookrightarrow A) \implies |A| = |B|.$$

\subsection*{Представление множеств в программах}

\paragraph{Определение представления}
\textbf{Представить объект} (множество) в программе --- значит описать:
\begin{enumerate}
    \item \textbf{Структуру данных}, используемую для хранения информации о множестве (например, о принадлежности элементов).
    \item \textbf{Алгоритмы} над этими структурами, реализующие операции над множествами (объединение, пересечение и т.д.).
\end{enumerate}
Выбор представления (например, битовые шкалы, списки, хеш-таблицы) зависит от особенностей множества, состава и частоты использования операций.

\subsubsection*{Битовые шкалы (Set as Bit Array)}
Пусть задан конечный универсум $U = \{u_1, \ldots, u_n\}$, где $|U| \le n$ (разрядности компьютера).
Подмножество $A \subset U$ представляется кодом (\textbf{битовой шкалой}) $C: \text{array} [1..n] \text{ of } 0..1$, где:
$$C[i] = 1 \iff u_i \in A.$$

\paragraph{Операции над битовыми шкалами}
Операции над небольшими множествами в этом представлении выполняются весьма эффективно (часто одной машинной командой):
\begin{itemize}
    \item \textbf{Пересечение} $(A \cap B)$: поразрядное логическое \texttt{И} кодов $C_A$ и $C_B$.
    \item \textbf{Объединение} $(A \cup B)$: поразрядное логическое \texttt{ИЛИ} кодов $C_A$ и $C_B$.
    \item \textbf{Дополнение} $(\overline{A})$: поразрядная \texttt{ИНВЕРСИЯ} кода $C_A$.
\end{itemize}

\textbf{ЗАМЕЧАНИЕ:} Если $|U|$ превосходит размер машинного слова, используются \textbf{массивы битовых шкал} (массивы машинных слов), а операции реализуются циклами по элементам массива.

\subsubsection*{Генерация всех подмножеств универсума}

Для генерации всех $2^n$ подмножеств $n$-элементного множества $\{a_1, \ldots, a_n\}$ используется соответствие: каждое целое число $i$ от $0$ до $2^n-1$ представляет одно подмножество.

\paragraph{Алгоритм 1.1 Генерация всех подмножеств}
\textbf{Вход:} $n \ge 0$ --- мощность множества.
\textbf{Выход:} последовательность кодов подмножеств $i$.
\begin{verbatim}
for i from 0 to 2^n - 1 do
    yield i  { код очередного подмножества }
end for
\end{verbatim}

\subsubsection*{Алгоритм построения бинарного кода Грея}

Алгоритм генерирует последовательность всех подмножеств так, что каждое следующее подмножество получается из предыдущего \textbf{изменением в точности одного элемента} (удалением или добавлением).

\paragraph{Алгоритм 1.2 Построение бинарного кода Грея}
\textbf{Вход:} $n \ge 0$ --- мощность множества.  
\textbf{Выход:} последовательность кодов подмножеств $B$.
\begin{verbatim}
B : array [1..n] of 0..1  { битовая шкала }
for i from 1 to n do
    B[i] := 0 { инициализация }
end for

yield B { пустое множество }
for i from 1 to 2^n - 1 do
    p := Q(i) { номер элемента для изменения }
    B[p] := 1 - B[p] { инверсия бита }
    yield B { очередное подмножество }
end for
\end{verbatim}

\paragraph{Функция $Q$}
Функция $Q(i)$ возвращает номер разряда $p$, подлежащего изменению. $Q(i)$ определяется как \textbf{количество нулей на конце двоичной записи числа $i$}, увеличенное на $1$.

\paragraph{Алгоритм 1.3 Функция $Q$ определения изменяемого разряда}
\textbf{Вход:} $i$ --- номер подмножества.
\textbf{Выход:} номер изменяемого разряда $q$.
\begin{verbatim}
q := 1; j := i
while j четно do
    j := j / 2
    q := q + 1
end while
return q
\end{verbatim}
